[{"title":"nodeHttp服务器","date":"2017-01-04T14:18:18.000Z","path":"2017/01/04/nodeHttp服务器/","text":"1.http服务器链式写法 1234567891011121314var http = require(&quot;http&quot;);//引入http模块http.createServer(function(req,res)&#123; //创建服务器,回调函数中参数分别为请求报文对象和响应报文对象 console.log(&quot;你正在访问的是&quot; + req.url); console.log(&quot;你现在使用的method是&quot; + req.method); //响应报文对象写入响应头 res.writeHead(200,&#123;&quot;Content-Type&quot;:&quot;text/plain;charset=utf-8&quot;&#125;); res.write(&quot;helloworld&quot;); //关闭响应 res.end(); //监听3000端口&#125;).listen(3000,function()&#123; console.log(&quot;服务器开启成功，正在监听3000端口&quot;);&#125;); 2.http服务器常规写法1234567891011var http = require(&quot;http&quot;);var server = http.createServer();server.on(&quot;request&quot;,function(req,res)&#123; res.writeHead(200,&#123;&quot;Content-Type&quot;:&quot;text/plain;charset=utf-8&quot;&#125;); res.write(&quot;&quot; + req.url + req.method + req.headers); res.end();&#125;);server.listen(3000,function()&#123; console.log(&quot;服务器开启成功，正在监听3000端口&quot;);&#125;);","tags":[{"name":"node服务器","slug":"node服务器","permalink":"http://hunghoo.github.io/tags/node服务器/"}]},{"title":"知识点整理","date":"2016-09-09T00:42:02.000Z","path":"2016/09/09/面试题/","text":"前端知识点总结 html 如何使用一套方案适配不同的终端 流式布局 使用非固定像素来定义网页内容，就是百分比布局 rem布局 使用rem这个根相对单位来适配移动端 响应式布局 其实可以利用媒体查询@media 响应式和移动web开发的区别 应用场景: 移动web + pc端 ：一般用于已经存在pc端，开发移动站的时候，只需要开发移动端 响应式开发 ：针对的是新建的站，一套页面适配各种终端，灵活 开发： 移动web + pc端 ：针对性强，开发效率高 响应式开发 ：兼容各种终端，开发效率低 适配： 移动web + pc端 ： 只适配移动设备，在pad设备上兼容性较差 响应式开发 ：可以适配各种终端 效率： 移动web + pc端 ：代码简洁，加载快速 响应式开发 ：代码相对复杂，加载较慢 什么是web语义化 就是可以让浏览器更好的读懂代码，在编写html时尽量使用带有语义化的标签，易于进行web操作和seo，同时也方便团队的协作。 DOCTYPE 是一种标准通用标记语言的文档类型声明，告诉解析器应该使用什么样的类型来解析文档。 css ie和其他浏览器的代码识别类型 例如： 12345p &#123; color:green;// 常规浏览器 *color:blue;// 只有ie7可以识别 _color:red; // 只有ie6可以识别&#125; javascript ajax请求数据123456789101112var xhr = new XMLHttpRequest();//创建一个异步对象xhr.open(&quot;post&quot;,&quot;index.html&quot;,true);//三个参数分别为1.发送请求的方式；2.请求的页面//xhr.open(&quot;get&quot;,&quot;index.html&quot;,true);//xhr.setRequestHeader(&quot;COntent-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);//post方式发送数据xhr.onreadystatechange= function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status==200)&#123; xhr.responseText;//获取到的数据 &#125;&#125;;xhr.send(null);//get方式//xhr.send(&quot;name=jack&amp;age=20&quot;);//post方式请求数据均是明文 如何实现跨域 最流行就是jsonp方式了 实现原理： 利用的主要是script标签可以获得不同域名上的内容 js中: 12345//定义的回调函数function dosomething(data)&#123; //处理数据代码&#125;&lt;script src=&quot;http://baidu.com?callback=dosomething&quot;&gt;&lt;/script&gt; php中的代码： 12345&lt;?php $callback = $_GET[&quot;callback&quot;];//得到回调函数名 $data = array(&quot;a&quot;,&quot;b&quot;);//要返回的数据 echo $callback.&apos;(&apos;. json_encode($data) .&apos;)&apos;;//输出?&gt; 优点：兼容性好；能够直接访问响应文本，支持浏览器和服务器之间的通信 缺点： 安全性较低，需要确保访问的网站安全，不会返回恶意代码。 js的作用域 由于js中不存在块级作用域，只存在函数级作用域，作用域是针对于变量的，比如创建了一个a1函数，在a1函数中创建了a2函数，那么就存在了三个作用域：全局作用域，a1作用域，a2作用域，并且包含关系为：全局包含a1作用域，a1包含a2作用域。当a1在查找变量时，就会在当前a1作用域中查找是否存在变量，如果没有找到就会查找其父级作用域即全局作用域是否存在需要的变量。如果在全局中也没有找到就会在全局中创建一个变量。这种查找形成了一种链式结构，所以又被成为作用域链。 js的闭包 理解闭包需要理解垃圾回收机制，当一个函数被执行完，其作用域就会被回收，而如果形成了闭包，执行完函数后其作用域也不会被回收。 如何形成闭包：某个函数被它父函数之外的某个变量引用，就会形成闭包。 闭包的作用就是保存自己的私有变量，通过提供的接口给外部使用，但是外部不能直接访问内部。 js原型链 Javascript 是面向对象的， 每个实例对象都有一个proto_属性， 该属性指向它原型对象， 这个实例对象的构造函数有一个原型属性 prototype，与实例的proto属性指向同一个对象。 当一个对象在查找一个属性的时，自 身没有就会根据proto__ 向 它的原型进行查找， 如果都没有， 则向它的原型的原型继续查找， 直到查到Object.prototype.proto为 nul， 这样也就形成了原型链 js继承 组合继承。 也叫伪经典继承。 指的是将原型链和借用构造函数的技术组合到一起， 从而发挥二者之长。思路： 使用原型链实现对原型属性属性和方法的继承， 通过借用构造函数来实现实例属性的继承。优点： 既通过在原型上定义方法实现了函数复用， 又能保证每一个实例都有它自己的数组。组合继承避免了原型链和借用构造函数的缺陷， 融合了他们的优点， 成为 JavaScript 中常用的继承模式。12345678910111213 // 定义一个动物类function Animal (name) &#123; // 属性 this.name = name || &apos;Animal&apos;; // 实例方法 this.sleep = function()&#123; console.log(this.name + &apos;正在睡觉！&apos;); &#125;&#125;// 原型方法Animal.prototype.eat = function(food) &#123; console.log(this.name + &apos;正在吃：&apos; + food);&#125;;","tags":[{"name":"前端知识点","slug":"前端知识点","permalink":"http://hunghoo.github.io/tags/前端知识点/"}]},{"title":"订阅者模式","date":"2016-07-09T04:42:02.000Z","path":"2016/07/09/订阅者模式/","text":"订阅者模式实践 理解观察者模式 简单的讲，一个对象作为特定任务或是另一对象的活动的观察者，并且在这个任务或活动发生时，利用事件的形式通知观察者。 观察者的使用场合 当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。 例如，用户A，B，C分别订阅某服务，当服务有更新是可设定更新、下载等操作。 实际业务中，如请求某个ajax后需要执行多个方法，数据处理、渲染页面、其他业务等，可以使用观察者 123456789101112131415161718192021222324252627282930313233343536373839404142 &lt;body&gt; &lt;p class=&quot;test&quot;&gt;&lt;/p&gt; &lt;script&gt; //订阅模式 var Observable = &#123; //存储回调函数 callbacks: [], //订阅函数 add: function(fn) &#123; this.callbacks.push(fn); &#125;, //发布函数 fire: function(data) &#123; this.callbacks.forEach(function(fn) &#123; fn(data); &#125;); &#125; &#125; //配置订阅函数的具体处理事件 Observable.add(function(data) &#123; $(&apos;.test&apos;).html(data.a) &#125;) //发ajax请求 $.ajax(&#123; url: &quot;test.json&quot;, context: document.body //成功后发布订阅的事件 &#125;).done(function(data) &#123; Observable.fire(data); &#125;) //test.json中的数据： /* &#123; &quot;a&quot;:1, &quot;b&quot;:2 &#125; */ &lt;/script&gt;&lt;/body&gt; 将订阅发布事件添加到jquery上12345678910111213141516171819202122~(function()&#123; var o = $(&#123;&#125;); //订阅事件 $.add = function()&#123; o.on.apply(o,arguments); &#125; //发布事件 $.publish = function()&#123; o.trigger.apply(o,arguments); &#125; $.off = function()&#123; o.off.apply(o,arguments); &#125;&#125;)();$.add(&quot;eventname&quot;,function(e,a,b,c)&#123; alert(a,b,c);&#125;);$.add(&quot;eventname&quot;,function(e,a,b,c)&#123; alert(&quot;ok&quot;);&#125;)$.publish(&quot;eventname&quot;,[1,2,3]);","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hunghoo.github.io/tags/设计模式/"}]},{"title":"js性能优化的一点总结","date":"2016-04-09T15:42:00.000Z","path":"2016/04/09/关于js性能优化的总结/","text":"优化建议 对数组进行循环遍历时，可以先讲数组的长度进行缓存，将数组长度放入局部变量中，避免多次查询数组长度。 尽量不要使用全局变量，因为全局的变量要比局部的变量访问速度慢，全局变量其实是window的对象成员，而局部变量是存储在函数的栈中。 123456var dom1 = document.getElementById(&quot;xx1&quot;);var dom2 = document.getElementById(&quot;xx2&quot;);//可以写成--&gt;var doc = document;var dom1 = doc.getElementById(&quot;xx1&quot;);var dom2 = doc.getElementById(&quot;xx2&quot;); 将数字转换为字符串时，推荐使用 “”+1 ,从性能上看，(“”+1) &gt; String() &gt; .toString() &gt; new String()。 浮点数转整型时，推荐使用Math.floor()或Math.round(),不推荐使用 parseInt() 此方法是用于将字符串转化为数字， 不要使用with()语句 with可以用来简化代码12345678910111213var qs = location.search.substring(1);var hostName = location.hostname;var url = location.href;可以写为--&gt;with (location)&#123; var qs = search.substring(1); var hostName = hostname; var url = href;&#125;//在这段代码中，使用了with语句关联了location对象，这就以为着在with代码块内部，每个变量首先被认为是一个局部变量，如果局部变量与location对象的某个属性同名，则这个局部变量会指向location对象属性。导致性能降低的原因是：使用了with关键字后，JS引擎无法对这段代码进行优化。JS引擎在代码执行之前有一个编译阶段，在不使用with关键字的时候，js引擎知道a是obj上的一个属性，它就可以静态分析代码来增强标识符的解析，从而优化了代码，因此代码执行的效率就提高了。使用了with关键字后，js引擎无法分辨出a变量是局部变量还是obj的一个属性，因此，js引擎在遇到with关键字后，它就会对这段代码放弃优化，所以执行效率就降低了。 谨慎使用闭包 对象属性和数组元素的访问速度都比变量和数值慢 减少dom的操作，尽量使用代理来操作dom； 将脚本放在底部 压缩js代码","tags":[{"name":"js","slug":"js","permalink":"http://hunghoo.github.io/tags/js/"}]},{"title":"emmet语法简介","date":"2015-01-02T07:11:28.000Z","path":"2015/01/02/emmet语法简介/","text":"对于为一个前端程序员，emmet可以说是作为一个神器的存在，可以让我们的coding效率提高很多。所以我就整理了下常用的emmet使用方法。 一 html1.初始化 如何快速搭建一个h5的结构，只需要一个命令 12! + tab键 或者 html:5 + tab键 如果要构建xhtml或者严格类型文档12html:xt --&gt; 过度文档类型html:4s --&gt; 严格文档类型 2.添加类 id 文本和属性 输入 .类名 或者 #id 单击tab键，就可以生成 1&lt;div class = &quot;classname&quot;&gt;&lt;/div&gt;或者&lt;div di=&quot;idname&quot;&gt;&lt;/div&gt; 默认生成div标签 如果添加上标签名，就会生成标签名和相应的class和id123eg： p.classname + tab --&gt;&lt;p class=&quot;classname&quot;&gt;&lt;/p&gt; p#idname + tab --&gt; &lt;p id=&quot;idname&quot;&gt;&lt;/p&gt; 也可以连写1p#idname.classname + tab --&gt; &lt;p id=&quot;idname&quot; class=&quot;calssname&quot;&gt;&lt;/p&gt; 如何生成内容和属性12p&#123;cont&#125; + tab --&gt; &lt;p&gt;cont&lt;/p&gt;a[href=&quot;#&quot;] + tab --&gt; &lt;a href=&quot;#&quot;&gt;&lt;/a&gt; 嵌套方式 来看例子12p&gt;span + tab --&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;p+div + tab --&gt; &lt;p&gt;&lt;/p&gt; &lt;div&gt;&lt;/div&gt; 分组 我们也可以通过嵌套和括号来生成代码块123456(.classname&gt;h1)+(#idname+h2)--&gt; &lt;div class=&quot;classname&quot;&gt; &lt;h1&gt;&lt;/h1&gt; &lt;/div&gt; &lt;div id=&quot;idname&quot;&gt;&lt;/div&gt; &lt;h2&gt;&lt;/h2&gt; 定义多个元素 使用*生成多个元素1234567ul&gt;li*3 -- &gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; 定义多个带属性的元素 使用$来生成序号1234567ul&gt;li.classname$*3--&gt; &lt;ul&gt; &lt;li class=&quot;classname1&quot;&gt;&lt;/li&gt; &lt;li class=&quot;classname2&quot;&gt;&lt;/li&gt; &lt;li class=&quot;classname3&quot;&gt;&lt;/li&gt; &lt;/ul&gt; 二 css快速写法1.值 大多数的属性默认生成单位是px, 不写就默认px e –&gt; em p –&gt; %123456eg:w100 --&gt; width:100px;w2e--&gt;width: 3em; 2.附加属性1234567891011@f+ -- &gt; @font-face &#123; font-family: &apos;FontName&apos;; src: url(&apos;FileName.eot&apos;); src: url(&apos;FileName.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;), url(&apos;FileName.woff&apos;) format(&apos;woff&apos;), url(&apos;FileName.ttf&apos;) format(&apos;truetype&apos;), url(&apos;FileName.svg#FontName&apos;) format(&apos;svg&apos;); font-style: normal; font-weight: normal; &#125; 3.添加兼容 -属性名 1234567-display -- &gt; -webkit-display: ; -moz-display: ; -ms-display: ; -o-display: ; display: ; emmet还有许多隐藏的快捷方式，常用的就是这么多…..","tags":[{"name":"emmet","slug":"emmet","permalink":"http://hunghoo.github.io/tags/emmet/"}]},{"title":"百度搜索框案例","date":"2014-04-02T03:39:18.000Z","path":"2014/04/02/百度搜索框案例/","text":"百度搜索框的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; fieldset, img, input, button &#123; border: none; padding: 0; margin: 0; outline-style: none; &#125; ul, ol &#123; list-style: none; margin: 0px; padding: 0px; &#125; #box &#123; width: 405px; margin: 200px auto; position: relative; &#125; #txtSearch &#123; float: left; width: 300px; height: 32px; padding-left: 4px; border: 1px solid #b6b6b6; border-right: 0; &#125; #btnSearch &#123; float: left; width: 100px; height: 34px; font: 400 14px/34px &quot;microsoft yahei&quot;; color: white; background: #3385ff; cursor: pointer; &#125; #btnSearch:hover &#123; background: #317ef3; &#125; #pop &#123; width: 303px; border: 1px solid #ccc; padding: 0px; position: absolute; top: 34px; &#125; #pop ul li &#123; padding-left: 5px; &#125; #pop ul li:hover &#123; background-color: #CCC; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;txtSearch&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;百度一下&quot; id=&quot;btnSearch&quot;&gt;&lt;/div&gt;&lt;script&gt; //真正的业务逻辑是 根据我们的输入 向有台发送数据 在后台匹配 把匹配好的发给我们 var datas = [&quot;a&quot;, &quot;abc&quot;, &quot;abbbb&quot;, &quot;abxxxx&quot;, &quot;xyz&quot;, &quot;abcdef&quot;, &quot;abzzzz&quot;]; //我们这里为了效果好看就在前台匹配了 //匹配的逻辑就是 从集合中找 如果 集合中的字符串是以我输入的字符串开头的就算匹配 //在文本框中输入 按照输入的内容 到datas里面 找匹配的项目 将匹配的项目放到新数组中 //输入的时候 判断匹配 var box = document.getElementById(&quot;box&quot;); var text = document.getElementById(&quot;txtSearch&quot;); text.onkeyup = function () &#123; var filterArr = []; var val = this.value;//文本框中的内容 //遍历datas 判断每一项是否匹配 for (var i = 0; i &lt; datas.length; i++) &#123; var data = datas[i];//每一项数据 if (data.indexOf(val) === 0) &#123;//当前这个数据 是以val开头的 filterArr.push(data);//把匹配的项目 放到新数组中 &#125; &#125; //console.log(filterArr); //1.判断之前有没有popDiv 如果有就移除 var popDiv = document.getElementById(&quot;pop&quot;); if (popDiv) &#123; box.removeChild(popDiv);//如果有 就把之前的移除 &#125; //2.如果没有匹配项 就不需要产生 popDiv if (filterArr.length === 0) &#123; return; &#125; //3.如果 文本框中是空字符串 不应该产生 popDiv if (val === &quot;&quot;) &#123; return; &#125; //根据filterArr动态生成结构 popDiv = document.createElement(&quot;div&quot;); popDiv.id = &quot;pop&quot;; box.appendChild(popDiv); var ul = document.createElement(&quot;ul&quot;); popDiv.appendChild(ul); //根据匹配数组 动态产生li for (var i = 0; i &lt; filterArr.length; i++) &#123; var item = filterArr[i]; var li = document.createElement(&quot;li&quot;); li.innerText = item; ul.appendChild(li); &#125; &#125;; //todo:当前高亮 //todo:点击当前li当前li中的文字会到输入框中 //todo:按上下键 可以切换（涉及到事件对象了，可以先了解一下试一下） //todo:可以自己看看百度搜索框还有哪些功能&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"特效案例","slug":"特效案例","permalink":"http://hunghoo.github.io/tags/特效案例/"}]}]