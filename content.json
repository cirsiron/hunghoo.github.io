[{"title":"npm的使用总结","date":"2017-02-01T14:18:18.000Z","path":"2017/02/01/npm的使用总结/","text":"npm的使用总结 包 包目录结构 package.json npm npm的含义 Node.js的开放式模块登记和管理系统 Node.js默认的模块管理器 npm package management 是一个基于node做的一个终端中的应用程序，叫做 npm 安装 npm 已经在第一次安装 node 的时候安装上了 基本使用 npm init [-y] 加 -y 参数表示直接生成 package.json 文件 npm install [–save] 包名 加上 –save 参数表示将当前安装的包添加到 package.json 文件中的依赖项中 npm uninstall [–save] 包名 升级npm npm install -g npm npm install -g 工具包名 http-server、less npm install -g http-server npm uninstall -g 包名 npm docs 包名 npm install npm install --save 包名 和 npm instlal -g 包名的区别 对于 npm install 包名 或者 npm install –save 包名来说，都是为了在项目中通过 require 加载改包。使用里面的功能。 对于包来说，还有一些基于node开发的一些命令行工具。一般这种工具，我们都是可以在全局命令行中直接就可以使用的，例如输入 node 命令，例如输入 npm 命令 安装第三方命令台工具的时候，一定要加 -g 参数 例如：less 就是是基于 node 开发一个命令行终端程序，可以用来将 less 语法的文件编译成 css 文件 解决切换版本造成全局工具包丢失问题 通过 npm root -g 查看全局包安装位置 通过 npm config set prefiex &quot;路径&quot; node 的最新版已经没有这个问题了 解决npm被墙问题 cnpm 一种方式在安装包的可以动态的指定镜像源地址 npm install underscore –registry=https://registry.npm.taobao.org 淘宝做了一个 cnpm 全局命令行工具，类似于 npm ,使用 cnpm 默认从淘宝的镜像源下载 npm install -g cnpm cnpm install [–save] 包名 cnpm install -g 包名 cnpm uninstall … nrm npm registry manage nrm 是一个全局命令行工具 npm install -g nrm nrm use taobao 当加载一个第三包的时候，内部查找机制 例如在 foo.js 文件中写了这样的一句代码：require(&#39;underscore&#39;) 首先node会在foo.js所属目录下找一个叫做 node_modules 的目录 如果找到 node_modules 目录，那么找该目录下有没有一个叫做 underscore 的目录 如果在 node_modules 目录找到 underscore 目录 那么node会在 underscore 目录下找一个叫做 package.json 的文件 如果找到 package.json 文件，那么node会在该文件中，找一个 main 的属性 如果找到该属性，那么 node 会将该属性指定的模块路径作为加载的路径，然后加载 如果在 underscore 目录下 没有 package.json 文件 或者 package.json 文件中没有 main 属性 或者 main 属性指定的入口模块不存在 那么 node 会在 underscore 目录下按照 index.js、index.json、index.node 的方式进行加载 如果在上面的流程中还没有找到 node 会自从进入当前目录的上一级目录下找 node_modules 目录开始查找，重复上面的流程 直到node进入当前文件所属的根路径（例如 c:/a/b/c/foo.js，那么根路径就是 c:/） 如果最后在根路径下还是找不到，最后报错。","tags":[{"name":"node","slug":"node","permalink":"http://hunghoo.github.io/tags/node/"}]},{"title":"node-express的入门使用教程","date":"2017-01-04T14:18:18.000Z","path":"2017/01/04/node-express的使用教程/","text":"1.express的使用 使用node创建服务器的原生思路是：1、创建服务器2、判断req.url和req.method3、调用fs.readFile从本地文件夹当中读取对应的静态资源4、使用mime第三方模块5、响应回去 使用express框架1234567891011121314//使用express框架//引入expresslet express = require(&quot;express&quot;);let app = express();app.use((res, req) =&gt; &#123; if (req.url.endsWidth(&quot;.css&quot;)) &#123; &#125; else if (req.url.endsWidth(&quot;.js&quot;)) &#123; &#125;&#125;).listen(3000, () =&gt; &#123; console.log(&quot;服务器已开启，请访问3000端口&quot;);&#125;); req的属性说明// **在app.use()中的回调函数有req和res两个对象 12345678910111213let express = require(&quot;express&quot;);let app = express();app.use((req,res)=&gt;&#123; console.log(res.url);//请求的路径 console.log(res.method);//请求的方法 &quot;GET&quot; console.log(res.query);//请求的参数 ?name=&quot;jack&quot; console.log(res.hostname);//请求的主机 console.log(res.ip);//请求的ip&#125;);//注意其中url和mehtod以及query属性是非常常用的属性app.listen(3000,()=&gt;&#123; console.log(&quot;监听3000端口&quot;);&#125;) 简洁写法 123456789//使用express简洁写法let express = require(&quot;express&quot;);let app = express();//可以指定多个静态资源路径app.use(express.static(&quot;./public&quot;));app.use(express.static(&quot;./static&quot;));app.listen(3000, () =&gt; &#123; console.log(&quot;server start&quot;);&#125;); 如何处理请求 GET请求 1234567891011let express = require(&quot;express&quot;);let app = express();//getapp.get(&quot;/&quot;,(req,res)=&gt;&#123; //返回数据 res.send(&quot;hello world&quot;);&#125;);let server = app.listen(3000,&quot;127.0.0.1&quot;,()=&gt;&#123; console.log(&quot;服务器已开启，请访问3000端口&quot;); console.log(server.address().address + server.address().port);&#125;); post数据类似 路由的使用 基本路由123456789101112let express = require(&quot;express&quot;);let app = express();app.get(&quot;/&quot;,(req,res)=&gt;&#123; res.send(&quot;/&quot;);&#125;);app.get(&quot;/add&quot;,(req,res)=&gt;&#123; res.send(&quot;/add&quot;);&#125;);let server = app.listen(3000,()=&gt;&#123; console.log(&quot;服务器已经开启&quot;);&#125;); 进阶路由 1234567891011121314151617181920212223242526272829let express = require(&quot;express&quot;);let app = express();//匹配acd和abcdapp.get(&quot;/ab?cd&quot;,(req,res)=&gt;&#123; res.send(&quot;/ab?cd&quot;);&#125;);//匹配abcd/abbcd/...app.get(&quot;/ab+cd&quot;,(req,res)=&gt;&#123; res.send(&quot;/add&quot;);&#125;);//匹配abcd/abbcd/...app.get(&quot;/ab+cd&quot;,(req,res)=&gt;&#123; res.send(&quot;/add&quot;);&#125;);//匹配abcd/abxxcd/...此处的*不等同于正则中的*//注意：这里面的*代表的是通配符，//和js里面的正则并不是所有的保持一致的,代表的是任意字符//（任意个任意字符）app.get(&quot;/ab*cd&quot;,(req,res)=&gt;&#123; res.send(&quot;/add&quot;);&#125;);//匹配abe/abcde/...app.get(&quot;/ab(cd)?e&quot;,(req,res)=&gt;&#123; res.send(&quot;/add&quot;);&#125;);let server = app.listen(3000,()=&gt;&#123; console.log(&quot;服务器已经开启&quot;);&#125;); 路由参数 123456789let express = require(&quot;express&quot;);let app = express();app.get(&quot;/abc/:id/:page&quot;,()=&gt;&#123; console.log(req.params);//:id相当于占位符 res.send(&quot;访问/abc&quot;);&#125;);+ http://127.0.0.1:3000/bcd?page=100&amp;totoalNum=300像这种风格，就用req.query+ http://127.0.0.1:3000/bcd/100/300,就用req.params route方法作用：可以在匹配到相应的请求后，根据请求的方法是GET还是post,做不同的处理let express = require(“express”);let app = express(); app.route(“/abc”) .get((req,res)=&gt;{ res.send(“get”); }) .post((req,res)=&gt;}{ res.send(“post”); })let server = app.listen(3000,()=&gt;{ console.log(“server start”); console.log(server.address());}); 路由Router对象： 可以使用express.Router()let express = require(“express”);let router = express.Router(); router.route(“/abc”) .get((req,res)=&gt;{ res.send(“/abc-get”); }) .post((req,res)=&gt;{ res.send(“/abc-post”); })//注意和前面的app.route对象的区别 中间件 中间件的本质就是一个函数 一个中间件一般只完成一个功能 请求的过程可以与自来水净化过程类比 每个操作过程都可以成为一个中间件 语法：app.use(中间件) eg: 1234567891011121314151617let express = require(&quot;express&quot;);let app = express();app.use((req,res,next=&gt;&#123; console.log(&quot;我是第一个中间件&quot;); next();&#125;);app.use((req,res,next)=&gt;&#123; console.log(&quot;我是第二个中间件&quot;);&#125;);app.use(&quot;/abc&quot;,(req,res,next)=&gt;&#123; console.log(&quot;我是第二个中间件&quot;); res.send(&quot;hello&quot;);&#125;);let server = app.listen(3000,()=&gt;&#123;&#125;); 常见的第三方插件 express-formidable 作用：处理浏览器提交的表单信息","tags":[{"name":"node express","slug":"node-express","permalink":"http://hunghoo.github.io/tags/node-express/"}]},{"title":"nodeHttp服务器","date":"2017-01-04T14:18:18.000Z","path":"2017/01/04/nodeHttp服务器/","text":"1.http服务器链式写法 1234567891011121314var http = require(&quot;http&quot;);//引入http模块http.createServer(function(req,res)&#123; //创建服务器,回调函数中参数分别为请求报文对象和响应报文对象 console.log(&quot;你正在访问的是&quot; + req.url); console.log(&quot;你现在使用的method是&quot; + req.method); //响应报文对象写入响应头 res.writeHead(200,&#123;&quot;Content-Type&quot;:&quot;text/plain;charset=utf-8&quot;&#125;); res.write(&quot;helloworld&quot;); //关闭响应 res.end(); //监听3000端口&#125;).listen(3000,function()&#123; console.log(&quot;服务器开启成功，正在监听3000端口&quot;);&#125;); 2.http服务器常规写法1234567891011var http = require(&quot;http&quot;);var server = http.createServer();server.on(&quot;request&quot;,function(req,res)&#123; res.writeHead(200,&#123;&quot;Content-Type&quot;:&quot;text/plain;charset=utf-8&quot;&#125;); res.write(&quot;&quot; + req.url + req.method + req.headers); res.end();&#125;);server.listen(3000,function()&#123; console.log(&quot;服务器开启成功，正在监听3000端口&quot;);&#125;);","tags":[{"name":"node服务器","slug":"node服务器","permalink":"http://hunghoo.github.io/tags/node服务器/"}]},{"title":"git的知识点总结","date":"2016-12-06T13:11:08.000Z","path":"2016/12/06/git知识点总结/","text":"Git Git是一款源代码管理工具(版本控制工具) 分布式版本管理工具，集中式 git属于分布式 svn集中式 git安装初始化 仓库 其实就是创建了一个.git隐藏目录 命令:git init; 想在哪个目录创建.git目录，就是哪个目录打开工具然后写命令. 一般是在项目的根目录执行这个命令. 用户信息 配置用户名 : git config user.name &quot;testName&quot; 配置邮箱 : git config user.email &quot;test@sina.com&quot; 查看配置信息: git config --list提交代码 1.先把代码添加到暂存区 命令:git add 文件路径 示例:git add ./reademe.md 可以使用git add .这个命令，批量把当前目录下所有修改过的文件添加到暂存区。 2.把暂存区的文件提交仓库里 命令: git commit -m &quot;注释&quot; 示例: git commit -m &quot;我们添加了一个新的功能&quot; -m 表示指定一个字符串，作为提交的说明(相当于注释); 合并add 与commit 命令 git commit -a -m &quot;这是使用合并添加与提交的操作&quot;; 这里-a参数表明把所有修改后的文件一起添加到暂存区.(只是对修改后的文件有效，对于新添加的文件没有作用) 查看工作区状态 命令:git status 如果没有报错说明一切正常，如果显示红色，说明可能有为提交至仓库 如果有绿色说明可能已经添加但是没有提交至仓库。添加忽略文件 在项目中有一些文件是不需要提交的,我们需要把它忽略掉 需要在.git文件夹所在目录新建一个名为.gitignore的文件然后在这个文件中写上需要被忽略的文件的路径。示例: /css/a.css: /css/*.css : /a.html 比对文件差异 命令: git diff 用来比较暂存区文件内容与工作区文件内容的区别 如果暂存区没有文件，就会将工作与代码与最近一次提交对比 命令：git diff --cached 比较暂存区的文件和仓库中文件的区别 对比之前某两次提交的文件的差异 命令:git diff [版本号1] [版本号2] [想比较的文件路径] 查看日志 命令:git log,可以查看每一次提交的日志 命令:git log --oneline 表示使用简洁的形式输出提交日志 版本回退 命令:git reset --hard Head~0 回退到上次提交时的状态,~0可以省略 命令:git reset --hard Head~1 这是将代码回退到上上一次提交时的状态 命令:git reset --hard Head~2 回退到上上上次 命令:git reset --hard 版本号 通过每次提交时生成的版本号来回退版本 通过git reflog命令可以查看之前所有版本切换的操作记录，可以通过这个命令得到的版本号回退到指定的版本。 创建分支 命令:git branch [分支名] 创建一个新分支 命令:git branch 查看当前所有的分支 切换分支 命令:git checkout [分支名] 切换分支后可以在切换后的分支中进行正常的操作 合并分支 命令:git merge [分支名] git会将指定的分支合并到当前分支. 删除分支 命令:git branch -d [分支名] 删除指定分支，-d参数表示要执行删除操作 git提交中的冲突 如果git不能自动合并分支，就会有冲突，我们需要手动解决冲突，然后再次提交 githubgithub与git git 版本管理工具 github 就是一个网站，只是这个网站提供git服务器的功能 上传代码到git服务器(push) 命令:git push [远程服务器地址] [远程服务器的分支] 示例:git push https://github.com/huoqishi/test002.git master 上传时可以使用一些简化的命令 将远程服务器地址写成变量的形式 git remote add [变量名] [远程服务器地址] 示例:git remote add origin https://github.com/huoqishi/test002.git 这样之后就可以直接使用origin来代替git push 后面写的地址了git push origin master 还可以尽一步简化 在push时加上-u参数，就会默认建立本地当前分支与远程指定分支的关联,下一次push时就不需要输入分支名了git push origin; ###","tags":[{"name":"node git","slug":"node-git","permalink":"http://hunghoo.github.io/tags/node-git/"}]},{"title":"知识点整理","date":"2016-09-09T00:42:02.000Z","path":"2016/09/09/面试题/","text":"前端知识点总结 html 如何使用一套方案适配不同的终端 流式布局 使用非固定像素来定义网页内容，就是百分比布局 rem布局 使用rem这个根相对单位来适配移动端 响应式布局 其实可以利用媒体查询@media 响应式和移动web开发的区别 应用场景: 移动web + pc端 ：一般用于已经存在pc端，开发移动站的时候，只需要开发移动端 响应式开发 ：针对的是新建的站，一套页面适配各种终端，灵活 开发： 移动web + pc端 ：针对性强，开发效率高 响应式开发 ：兼容各种终端，开发效率低 适配： 移动web + pc端 ： 只适配移动设备，在pad设备上兼容性较差 响应式开发 ：可以适配各种终端 效率： 移动web + pc端 ：代码简洁，加载快速 响应式开发 ：代码相对复杂，加载较慢 什么是web语义化 就是可以让浏览器更好的读懂代码，在编写html时尽量使用带有语义化的标签，易于进行web操作和seo，同时也方便团队的协作。 DOCTYPE 是一种标准通用标记语言的文档类型声明，告诉解析器应该使用什么样的类型来解析文档。 css ie和其他浏览器的代码识别类型 例如： 12345p &#123; color:green;// 常规浏览器 *color:blue;// 只有ie7可以识别 _color:red; // 只有ie6可以识别&#125; javascript ajax请求数据123456789101112var xhr = new XMLHttpRequest();//创建一个异步对象xhr.open(&quot;post&quot;,&quot;index.html&quot;,true);//三个参数分别为1.发送请求的方式；2.请求的页面//xhr.open(&quot;get&quot;,&quot;index.html&quot;,true);//xhr.setRequestHeader(&quot;COntent-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);//post方式发送数据xhr.onreadystatechange= function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status==200)&#123; xhr.responseText;//获取到的数据 &#125;&#125;;xhr.send(null);//get方式//xhr.send(&quot;name=jack&amp;age=20&quot;);//post方式请求数据均是明文 如何实现跨域 最流行就是jsonp方式了 实现原理： 利用的主要是script标签可以获得不同域名上的内容 js中: 12345678//定义的回调函数function dosomething(data)&#123; //处理数据代码&#125;&lt;script src=&quot;http://baidu.com?callback=dosomething&quot;&gt;&lt;/script&gt; //注意：可以动态生成以上代码，实现跨域 php中的代码： 12345&lt;?php $callback = $_GET[&quot;callback&quot;];//得到回调函数名 $data = array(&quot;a&quot;,&quot;b&quot;);//要返回的数据 echo $callback.&apos;(&apos;. json_encode($data) .&apos;)&apos;;//输出?&gt; 优点：兼容性好；能够直接访问响应文本，支持浏览器和服务器之间的通信 缺点： 安全性较低，需要确保访问的网站安全，不会返回恶意代码。 js的作用域 由于js中不存在块级作用域，只存在函数级作用域，作用域是针对于变量的，比如创建了一个a1函数，在a1函数中创建了a2函数，那么就存在了三个作用域：全局作用域，a1作用域，a2作用域，并且包含关系为：全局包含a1作用域，a1包含a2作用域。当a1在查找变量时，就会在当前a1作用域中查找是否存在变量，如果没有找到就会查找其父级作用域即全局作用域是否存在需要的变量。如果在全局中也没有找到就会在全局中创建一个变量。这种查找形成了一种链式结构，所以又被成为作用域链。 js的闭包 理解闭包需要理解垃圾回收机制，当一个函数被执行完，其作用域就会被回收，而如果形成了闭包，执行完函数后其作用域也不会被回收。 如何形成闭包：某个函数被它父函数之外的某个变量引用，就会形成闭包。 闭包的作用就是保存自己的私有变量，通过提供的接口给外部使用，但是外部不能直接访问内部。 js原型链 Javascript 是面向对象的， 每个实例对象都有一个proto_属性， 该属性指向它原型对象， 这个实例对象的构造函数有一个原型属性 prototype，与实例的proto属性指向同一个对象。 当一个对象在查找一个属性的时，自 身没有就会根据proto__ 向 它的原型进行查找， 如果都没有， 则向它的原型的原型继续查找， 直到查到Object.prototype.proto为 nul， 这样也就形成了原型链 js继承 组合继承。 也叫伪经典继承。 指的是将原型链和借用构造函数的技术组合到一起， 从而发挥二者之长。思路： 使用原型链实现对原型属性属性和方法的继承， 通过借用构造函数来实现实例属性的继承。优点： 既通过在原型上定义方法实现了函数复用， 又能保证每一个实例都有它自己的数组。组合继承避免了原型链和借用构造函数的缺陷， 融合了他们的优点， 成为 JavaScript 中常用的继承模式。1234567891011121314151617181920212223242526 // 定义一个父类function Animal (name) &#123; // 属性 this.name = name || &apos;Animal&apos;; // 实例方法 this.sleep = function()&#123; console.log(this.name + &apos;正在睡觉！&apos;); &#125;&#125;// 原型方法Animal.prototype.eat = function(food) &#123; console.log(this.name + &apos;正在吃：&apos; + food);&#125;;//定义一个子类function Cat(name)&#123; Animal.call(this); this.name = name || &apos;Tom&apos;;&#125;Cat.prototype = new Animal();// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 此方法有一个问题会在原型上和实例上都生成属性方法 Cat.prototype = new Animal();//在原型对象上生成了属性方法 var cat = new Cat();//在实例对象上又一次生成了相同的属性方法SubType.prototype=new SuperType();//这样subType.prototype作为SuperType的实例，SubType.prototype就拥有了SuperType 的实例属性，这些实例属性(这里指的是SuperType的name,colors属性)可以被SubType的任意实例通过proto访问到。 寄生组合式继承 123456789101112131415function Object(o)&#123; function F()&#123;&#125; F.prototype=o; return new F();&#125;function inheritPrototype(subType, superType) &#123; var prototype = Object(superType.prototype); //创建对象 prototype.constructor = subType; //增强对象 subType.prototype = prototype; //指定对象&#125;两种情况的差异所在：组合继承，因为有实例属性存在，所以subType.protype就拥有了其实例属性。寄生组合继承，由于F()&#123;&#125;是空的，即是subType.protype不会拥有任何实例属性。 常用字符串的操作方法： charAt();//返回指定索引位置处的字符。如果超出范围就返回空字符串 slice();//返回字符串的片段 substr();//返回一个从指定位置开始的指定长度的字符串 substring();//返回指定位置的字符串 indexOf();//返回第一次出现的字符串的位置 lastIndexOf();//返回最后一次出现的字符串的位置 search();//返回与正则匹配的第一个字符串的位置 concat();返回连接后的字符串 split();//将字符串按照指定的标识分割成数组，并返回 判断变量是否是数组 1234567function isArray(arr)&#123; if(typeof Array.isArray === &quot;function&quot;)&#123; return Array.isArray(arr); &#125;else&#123; return Object.prototype.toString().call([]) === &quot;[object Array]&quot; &#125;&#125; js 的异步加载有哪几种方法？ 方案一：标签的 async=”async”属性。 HTML5 中新增的属性，Chrome、 FF、 IE9&amp;IE9+均支持（ IE6~8不支持）。 此外， 这种方法不能保证脚本按顺序执行。 方案二： 标签的 defer=”defer”属性。 兼容所有浏览器。 此外， 这种方法可以确保所有设置 defer 属性的脚本按顺序执行。 列举浏览器对象模型 BOM 里常用的至少 4 个对象， 并列举 window 对象的常用方法至少 5 个？ 对象： Window document location screen history navigator方法： Alert() confirm() prompt() open() close() arguments对象 arguments[]函数参数的数组 函数的参数和其他属性 arguments.callee arguments.length —– arguments.callee.length 比较实参与形参的个数，多态的实现 array 数组对象 arr.length; arr.concat(); arr.join(“–”); arr.push(); arr.pop(); arr.shift(); arr.unshift(); arr.toString(); arr.reverse(); arr.slice(); arr.sort(); arr.map(); arr.forEach(); arr.filter(); HTML5本地存储 特性： 设置、读取方便 只能存储字符串，需要将JSON.stringfy()编码后存储 容量大，sessionStorage（4-5M）或者localStorage(20M); sessionStorage 生命周期为关闭浏览器窗口之前 在同一个窗口下数据可以共享 localStorage 永久生效，除非手动删除+可以多窗口共享 相关API setItem(key,value); getItem(key); removeItem(key); clear();//清空所有存储内容 key(n);//按索引来获取存储内容 js的事件流模型都有什么？如何阻止？ 原始事件模型 eg：onclick, DOM2事件类型 addEventListener(“mouseleave”,function(){},boolean); removeEventListener(“mouseleave”,callbackName,boolean); IE模型+ attachEvent(“on” + “mouseleave”,callbackName); detachEvent(“on” + “mouseleave”,callbackName); nth-of-type与nth-child区别 ele:nth-of-type(n)是指父元素下第n个ele元素 ele:nth-child(n)是指父元素下第n个元素且这个元素为ele，若不是，则选择失败。 伪类和伪元素 伪类：类，class是一个类，就类似class这样，表示一些元素的状态的，但是无须标识的分类。 a:link a:visited a:hover a:active; 结构型伪类选择器：:root()等同于 :not()-&gt;除某个元素之外的元素 empty target first-child last-child nth-child nth-last-child//注意是从1开始 nth-of-type nth-last-of-type 伪元素:就是一个元素，类似p标签元素，等等，逻辑上存在，但是实际并不存在在文档树中。 ::first-line //某个元素的第一行文字的使用样式 ::first-letter//某个元素的文字中的首字母 ::before //在某个元素之前插入一些内容 ::after //在某个元素之后插入一些内容 性能优化： 网页内容： 减少http请求 减少DNS查询次数 缓存ajax 延迟加载 如何使用svg + 123if (!Modernizr.svg) &#123; $(&quot;.logo img&quot;).attr(&quot;src&quot;, &quot;images/logo.png&quot;);&#125;","tags":[{"name":"前端知识点","slug":"前端知识点","permalink":"http://hunghoo.github.io/tags/前端知识点/"}]},{"title":"订阅者模式","date":"2016-07-09T04:42:02.000Z","path":"2016/07/09/订阅者模式/","text":"订阅者模式实践 理解观察者模式 简单的讲，一个对象作为特定任务或是另一对象的活动的观察者，并且在这个任务或活动发生时，利用事件的形式通知观察者。 观察者的使用场合 当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。 例如，用户A，B，C分别订阅某服务，当服务有更新是可设定更新、下载等操作。 实际业务中，如请求某个ajax后需要执行多个方法，数据处理、渲染页面、其他业务等，可以使用观察者 123456789101112131415161718192021222324252627282930313233343536373839404142 &lt;body&gt; &lt;p class=&quot;test&quot;&gt;&lt;/p&gt; &lt;script&gt; //订阅模式 var Observable = &#123; //存储回调函数 callbacks: [], //订阅函数 add: function(fn) &#123; this.callbacks.push(fn); &#125;, //发布函数 fire: function(data) &#123; this.callbacks.forEach(function(fn) &#123; fn(data); &#125;); &#125; &#125; //配置订阅函数的具体处理事件 Observable.add(function(data) &#123; $(&apos;.test&apos;).html(data.a) &#125;) //发ajax请求 $.ajax(&#123; url: &quot;test.json&quot;, context: document.body //成功后发布订阅的事件 &#125;).done(function(data) &#123; Observable.fire(data); &#125;) //test.json中的数据： /* &#123; &quot;a&quot;:1, &quot;b&quot;:2 &#125; */ &lt;/script&gt;&lt;/body&gt; 将订阅发布事件添加到jquery上12345678910111213141516171819202122~(function()&#123; var o = $(&#123;&#125;); //订阅事件 $.add = function()&#123; o.on.apply(o,arguments); &#125; //发布事件 $.publish = function()&#123; o.trigger.apply(o,arguments); &#125; $.off = function()&#123; o.off.apply(o,arguments); &#125;&#125;)();$.add(&quot;eventname&quot;,function(e,a,b,c)&#123; alert(a,b,c);&#125;);$.add(&quot;eventname&quot;,function(e,a,b,c)&#123; alert(&quot;ok&quot;);&#125;)$.publish(&quot;eventname&quot;,[1,2,3]);","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hunghoo.github.io/tags/设计模式/"}]},{"title":"ie与标准浏览器的兼容总结","date":"2016-04-12T06:22:11.000Z","path":"2016/04/12/ie与标准浏览器的兼容总结/","text":"JS兼容性 var e = e || window.event; document.documentElement || document.body xx.currentStyle || getComputedStyle(xx,null);//IE–FF event.cancelBubble = true || event.stopPropagation(); xx.getElementsByClassName();//ie8以上 xx.querySelector(); xx.querySelectorAll(); xx.nextElementSiblings; target – srcElement; e.preventDefault()–e.returnValue = false; 获取鼠标当前坐标 IE：event.x和event.y。 FF：event.pageX和event.pageY。 通用：两者都有event.clientX和event.clientY属性。","tags":[{"name":"兼容总结","slug":"兼容总结","permalink":"http://hunghoo.github.io/tags/兼容总结/"}]},{"title":"前端性能优化的一点总结","date":"2016-04-09T15:42:00.000Z","path":"2016/04/09/关于js性能优化的总结/","text":"优化建议 （ 1） 资源加载 CSS 顶部， JS 底部 CSS JS 文件压缩 尽量使用图片使用精灵图， 字体图标 图片加载可通过懒加载的方式。 总之就是减少资源体积减少资源请求次数。 （ 2） 代码性能 Css： 使用 CSS 缩写， 减少代码量； 减少查询层级： 如.header .logo 要好过.header .top .logo； 减少查询范围： 如.header&gt;li 要好过.header li； 避免 TAG 标签与 CLASS 或 ID 并存： 如 a.top、 button#submit； 删除重复的 CSS；…. Html： 减少 DOM 节点： 加速页面渲染； 正确的闭合标签： 如避免使用， 浏览器会多一个将它解析成的过程； 减少页面重绘。 比如 给图片加上正确的宽高值： 这可以减少页面重绘，…… js 对数组进行循环遍历时，可以先讲数组的长度进行缓存，将数组长度放入局部变量中，避免多次查询数组长度。 尽量不要使用全局变量，因为全局的变量要比局部的变量访问速度慢，全局变量其实是window的对象成员，而局部变量是存储在函数的栈中。 123456var dom1 = document.getElementById(&quot;xx1&quot;);var dom2 = document.getElementById(&quot;xx2&quot;);//可以写成--&gt;var doc = document;var dom1 = doc.getElementById(&quot;xx1&quot;);var dom2 = doc.getElementById(&quot;xx2&quot;); 将数字转换为字符串时，推荐使用 “”+1 ,从性能上看，(“”+1) &gt; String() &gt; .toString() &gt; new String()。 浮点数转整型时，推荐使用Math.floor()或Math.round(),不推荐使用 parseInt() 此方法是用于将字符串转化为数字， 不要使用with()语句 with可以用来简化代码12345678910111213var qs = location.search.substring(1);var hostName = location.hostname;var url = location.href;可以写为--&gt;with (location)&#123; var qs = search.substring(1); var hostName = hostname; var url = href;&#125;//在这段代码中，使用了with语句关联了location对象，这就以为着在with代码块内部，每个变量首先被认为是一个局部变量，如果局部变量与location对象的某个属性同名，则这个局部变量会指向location对象属性。导致性能降低的原因是：使用了with关键字后，JS引擎无法对这段代码进行优化。JS引擎在代码执行之前有一个编译阶段，在不使用with关键字的时候，js引擎知道a是obj上的一个属性，它就可以静态分析代码来增强标识符的解析，从而优化了代码，因此代码执行的效率就提高了。使用了with关键字后，js引擎无法分辨出a变量是局部变量还是obj的一个属性，因此，js引擎在遇到with关键字后，它就会对这段代码放弃优化，所以执行效率就降低了。 谨慎使用闭包 对象属性和数组元素的访问速度都比变量和数值慢 减少dom的操作，尽量使用代理来操作dom； 将脚本放在底部 压缩js代码","tags":[{"name":"js html css 前端 优化","slug":"js-html-css-前端-优化","permalink":"http://hunghoo.github.io/tags/js-html-css-前端-优化/"}]},{"title":"React系列学习7","date":"2016-04-02T04:45:32.000Z","path":"2016/04/02/React系列学习之07 受控表单和非受控表单/","text":"受控表单：设定了value值的input表单就是一个受控表单，此时的表单是不受你控制的. App.jsx12345678910111213import React, &#123;Component&#125; from 'react';class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;input type=\"text\" value=\"Hello!\"/&gt; &lt;/div&gt; ); &#125;&#125;export default App; 如果你想要改变这个值，就需要用到onChange事件。 App.jsx123456789101112131415161718192021222324import React, &#123;Component&#125; from 'react';class App extends Component &#123; constructor(props, context) &#123; super(props, context); this.state = &#123; inputVal: 'hello' &#125;; this.handleChange = this.handleChange.bind(this); &#125;; handleChange(event) &#123; this.setState(&#123;inputVal: event.target.value&#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;input type=\"text\" value=&#123;this.state.inputVal&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/div&gt; ); &#125;&#125;export default App; 不受控表单：value没有值或者值设为null的input是一个不受控组件。用户的任何输入都会反映到输入框中，可以使用defaultValue来给一个默认值，这个defaultValue和value是不一样的,这个defaultValue就像placefolder一样 App.jsx12345678910111213import React, &#123;Component&#125; from 'react';class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;input type=\"text\" value=&#123;null&#125;/&gt; &lt;/div&gt; ); &#125;&#125;export default App;","tags":[{"name":"React","slug":"React","permalink":"http://hunghoo.github.io/tags/React/"}]},{"title":"React系列学习6","date":"2016-03-23T14:12:55.000Z","path":"2016/03/23/React系列学习之06 组件生命周期/","text":"Component Life Cycle—组件生命周期 componentWillMount 在渲染前调用,在客户端也在服务端 一个组件绝对不可以自己修改自己的props 只能在子组件或者组件树外调用setProps，一定不可以使用this.setProps,可以使用this.setStates componentDidMount 第一次渲染后执行，仅在客户端. 这是发起AJAX请求或者操作DOM或者更新state的地方。ajax需要写在这个地方。 这个方法也用来整合其他第三方JS框架或者一些延迟执行的函数，例如setTimeout和setInterval. 我们用它来更新state，这样我们可以触发其他生命周期函数. componentWillReceiveProps 会被立即调用，当props被更新的时候. shouldComponentUpdate 应该返回一个布尔值. 它决定你的组件是否将要被更新，默认被设置为true. 如果你确定你的组件在state或props更新后不需要render， 那么你可以返回false。 componentWillUpdate 在组件更新之前调用; componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用。 componentWillUnmount 在组件从 DOM 中移除的时候立刻被调用。 App.jsx123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import React from 'react';class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; data: 0 &#125; //this的指向绑定到App上 this.setNewNumber = this.setNewNumber.bind(this) &#125;; setNewNumber() &#123; this.setState(&#123;data: this.state.data + 1&#125;) &#125; render() &#123; return ( &lt;div&gt; //此处的this还是App &lt;button onClick = &#123;this.setNewNumber&#125;&gt;INCREMENT&lt;/button&gt; &lt;Content myNumber = &#123;this.state.data&#125;&gt;&lt;/Content&gt; &lt;/div&gt; ); &#125;&#125;class Content extends React.Component &#123; componentWillMount() &#123; console.log('Component WILL MOUNT!') &#125; componentDidMount() &#123; console.log('Component DID MOUNT!') &#125; componentWillReceiveProps(newProps) &#123; console.log('Component WILL RECIEVE PROPS!') &#125; shouldComponentUpdate(newProps, newState) &#123; return true; &#125; componentWillUpdate(nextProps, nextState) &#123; console.log('Component WILL UPDATE!'); &#125; componentDidUpdate(prevProps, prevState) &#123; console.log('Component DID UPDATE!') &#125; componentWillUnmount() &#123; console.log('Component WILL UNMOUNT!') &#125; render() &#123; return ( &lt;div&gt; &lt;h3&gt;&#123;this.props.myNumber&#125;&lt;/h3&gt; &lt;/div&gt; ); &#125;&#125;export default App; main.js1234567import React from 'react';import ReactDOM from 'react-dom';import App from './App.jsx';ReactDOM.render(&lt;App/&gt;, document.getElementById('app'));setTimeout(() =&gt; &#123;ReactDOM.unmountComponentAtNode(document.getElementById('app'));&#125;, 10000);","tags":[{"name":"React","slug":"React","permalink":"http://hunghoo.github.io/tags/React/"}]},{"title":"React系列学习5","date":"2016-03-19T04:32:45.000Z","path":"2016/03/19/React系列学习之05 属性/","text":"使用属性 App.jsx1234567891011121314import React from 'react';class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.props.headerProp&#125;&lt;/h1&gt; &lt;h2&gt;&#123;this.props.contentProp&#125;&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;export default App; main.js12345678import React from 'react';import ReactDOM from 'react-dom';import App from './App.jsx';ReactDOM.render(&lt;App headerProp = \"Header from props...\" contentProp = \"Content from props...\"/&gt;, document.getElementById('app'));export default App; 默认属性 App.jsx12345678910111213141516171819import React from 'react';class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.props.headerProp&#125;&lt;/h1&gt; &lt;h2&gt;&#123;this.props.contentProp&#125;&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;App.defaultProps = &#123; headerProp: \"Header from props...\", contentProp:\"Content from props...\"&#125;export default App; main.js12345import React from 'react';import ReactDOM from 'react-dom';import App from './App.jsx';ReactDOM.render(&lt;App/&gt;, document.getElementById('app')); State和Props App.jsx1234567891011121314151617181920212223242526272829303132333435363738394041424344import React from 'react';class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; header: \"Header from props...\", \"content\": \"Content from props...\" &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;Header headerProp = &#123;this.state.header&#125;/&gt; &lt;Content contentProp = &#123;this.state.content&#125;/&gt; &lt;/div&gt; ); &#125;&#125;class Header extends React.Component &#123; render() &#123; return ( &lt;div&gt; //先执行app然后执行这个组件，此时可以读取到，这个属性值 &lt;h1&gt;&#123;this.props.headerProp&#125;&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125;class Content extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h2&gt;&#123;this.props.contentProp&#125;&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;export default App; main.js12345import React from 'react';import ReactDOM from 'react-dom';import App from './App.jsx';ReactDOM.render(&lt;App/&gt;, document.getElementById('app'));","tags":[{"name":"React","slug":"React","permalink":"http://hunghoo.github.io/tags/React/"}]},{"title":"React系列学习4","date":"2016-03-15T01:12:21.000Z","path":"2016/03/15/React系列学习之04 状态/","text":"State state是数据的来源，你应该尽量使state保持简单，并且最小化你状态组件的数量。相反，如果是个组件需要从state中获取数据，你应该新建一个容器组件来保存所有的状态 App.jsx1234567891011121314151617181920212223import React from 'react';class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; header: \"Header from state...\", \"content\": \"Content from state...\" &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.state.header&#125;&lt;/h1&gt; &lt;h2&gt;&#123;this.state.content&#125;&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;export default App; main.js12345import React from 'react';import ReactDOM from 'react-dom';import App from './App.jsx';ReactDOM.render(&lt;App /&gt;, document.getElementById('app'));","tags":[{"name":"React","slug":"React","permalink":"http://hunghoo.github.io/tags/React/"}]},{"title":"React系列学习3","date":"2016-03-12T03:23:41.000Z","path":"2016/03/12/React系列学习之03 组件/","text":"组件的实例 无状态示例 App.jsx1234567891011121314151617181920212223242526272829303132333435363738394041//首先引入reactimport React from 'react';//声明组件 Appclass App extends React.Component &#123; //ES6语法 render() &#123; return ( &lt;div&gt; //组合组件 //代表的是下面的组件，直接使用闭合标签包裹 &lt;Header/&gt; &lt;Content/&gt; &lt;/div&gt; ); &#125;&#125;//声明组件 Headerclass Header extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Header&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125;//声明组件 Contentclass Content extends React.Component &#123; //渲染 render() &#123; return ( &lt;div&gt; &lt;h2&gt;Content&lt;/h2&gt; &lt;p&gt;The content text!!!&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;//输出App 组件export default App; main.js模块123456//需要引入react和reactdomimport React from 'react';import ReactDOM from 'react-dom';import App from './App.jsx';//在主模块中渲染，第一个参数是组件名，第二个是渲染到指定的标签中ReactDOM.render(&lt;App/&gt;, document.getElementById('app')); 有状态组件实例 App.jsx12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import React from 'react';//声明App组件class App extends React.Component &#123; constructor() &#123; super(); //添加状态数据 this.state = &#123; data: [ &#123; \"id\":1, \"name\":\"Foo\", \"age\":\"20\" &#125;, &#123; \"id\":2, \"name\":\"Bar\", \"age\":\"30\" &#125;, &#123; \"id\":3, \"name\":\"Baz\", \"age\":\"40\" &#125; ] &#125; &#125; //渲染 render() &#123; return ( &lt;div&gt; //引入Header组件 &lt;Header/&gt; &lt;table&gt; &lt;tbody&gt; //数组遍历map，在前面声明了this.state.data，它是一个数组。 //person --&gt; items ,i--&gt;index, key是一个标识，表明每一项都是不相同的 &#123;this.state.data.map((person, i) =&gt; &lt;TableRow key = &#123;i&#125; data = &#123;person&#125; /&gt;)&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; ); &#125;&#125;class Header extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Header&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125;class TableRow extends React.Component &#123; render() &#123; return ( &lt;tr&gt; //this.props就是属性值,在渲染时从属性中获取到 &lt;td&gt;&#123;this.props.data.id&#125;&lt;/td&gt; &lt;td&gt;&#123;this.props.data.name&#125;&lt;/td&gt; &lt;td&gt;&#123;this.props.data.age&#125;&lt;/td&gt; &lt;/tr&gt; //ReactDOM.render ); &#125;&#125;export default App; main.js12345import React from 'react';import ReactDOM from 'react-dom';import App from './App.jsx';ReactDOM.render(&lt;App/&gt;, document.getElementById('app'));","tags":[{"name":"React","slug":"React","permalink":"http://hunghoo.github.io/tags/React/"}]},{"title":"React系列学习2","date":"2016-03-05T06:22:11.000Z","path":"2016/03/05/React系列学习之02 JSX/","text":"JSX 12345678910111213import React from 'react';class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; Hello World!!! &lt;/div&gt; ); &#125;&#125;export default App; 嵌套元素123456789101112131415import React from 'react';class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Header&lt;/h1&gt; &lt;h2&gt;Content&lt;/h2&gt; &lt;p&gt;This is the content!!!&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;export default App; 注意return中间必须用一个容器包裹起来 属性123456789101112131415import React from 'react';class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Header&lt;/h1&gt; &lt;h2&gt;Content&lt;/h2&gt; &lt;p data-myattr = \"somevalue\"&gt;This is the content!!!&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;export default App; Javascript表达式12345678910111213import React from 'react';class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;&#123;1+1&#125;&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125;export default App; 注意在JSX中不能使用if else，但是可以使用三元表达式12345678910111213141516import React from 'react';class App extends React.Component &#123; render() &#123; var i = 1; return ( &lt;div&gt; &lt;h1&gt;&#123;i == 1 ? 'True!' : 'False'&#125;&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125;export default App; 样式12345678910111213141516171819import React from 'react';class App extends React.Component &#123; render() &#123; var myStyle = &#123; fontSize: 100, color: '#FF0000' &#125; return ( &lt;div&gt; &lt;h1 style = &#123;myStyle&#125;&gt;Header&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125;export default App; 注意React会自动在number数值后面加上px； 注释123456789101112131415import React from 'react';class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Header&lt;/h1&gt; &#123;//End of the line Comment...&#125; &#123;/*Multi line comment...*/&#125; &lt;/div&gt; ); &#125;&#125;export default App; 注释1234567891011121314151617181920212223242526272829import React from 'react';class App extends React.Component &#123; render() &#123; var myStyle = &#123; fontSize: 100, color: 'blue' &#125; return ( &lt;div&gt; Hello world &#123; //这是单行注释 //这是单行注释 //这是单行注释 &#125; &#123; /* 多行注释 多行注释 多行注释 */ &#125; &lt;/div&gt; ); &#125;&#125;export default App; 命名约定 组件名字首字母大写 用className和htmlFor替换class和for","tags":[{"name":"React","slug":"React","permalink":"http://hunghoo.github.io/tags/React/"}]},{"title":"React系列学习1","date":"2016-03-03T06:22:11.000Z","path":"2016/03/03/React系列学习之01 环境配置/","text":"安装全局包 npm install -g babelnpm install -g babel-cli 创建根目录C:\\Users\\username\\Desktop&gt;mkdir reactAppC:\\Users\\username\\Desktop\\reactApp&gt;npm init 安装依赖和插件C:\\Users\\username&gt;npm install webpack --saveC:\\Users\\username&gt;npm install webpack-dev-server --save:\\Users\\username\\Desktop\\reactApp&gt;npm install react --saveC:\\Users\\username\\Desktop\\reactApp&gt;npm install react-dom --saveC:\\Users\\username\\Desktop\\reactApp&gt;npm install babel-coreC:\\Users\\username\\Desktop\\reactApp&gt;npm install babel-loaderC:\\Users\\username\\Desktop\\reactApp&gt;npm install babel-preset-reactC:\\Users\\username\\Desktop\\reactApp&gt;npm install babel-preset-es2015 创建文件C:\\Users\\username\\Desktop\\reactApp&gt;新建 index.htmlC:\\Users\\username\\Desktop\\reactApp&gt;新建 App.jsxC:\\Users\\username\\Desktop\\reactApp&gt;新建 main.jsC:\\Users\\username\\Desktop\\reactApp&gt;新建 webpack.config.js 设置编译器，服务器和加载器 webpack.config.js1234567891011121314151617181920212223242526272829var config = &#123; entry: &apos;./main.js&apos;, output: &#123; path:&apos;./&apos;, filename: &apos;index.js&apos;, &#125;, devServer: &#123; inline: true, port: 8080 &#125;, module: &#123; loaders: [ &#123; test: /\\.jsx?$/, exclude: /node_modules/, loader: &apos;babel&apos;, query: &#123; presets: [&apos;es2015&apos;, &apos;react&apos;] &#125; &#125; ] &#125;&#125;module.exports = config; 在package.json文件中的scripts中添加&quot;start&quot;: &quot;webpack-dev-server --hot&quot; index.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang = &quot;en&quot;&gt; &lt;head&gt; &lt;meta charset = &quot;UTF-8&quot;&gt; &lt;title&gt;React App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id = &quot;app&quot;&gt;&lt;/div&gt; &lt;script src = &quot;index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; App.jsx12345678910111213import React from &apos;react&apos;;class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; Hello World!!! &lt;/div&gt; ); &#125;&#125;export default App; main.js12345import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import App from &apos;./App.jsx&apos;;ReactDOM.render(&lt;App /&gt;, document.getElementById(&apos;app&apos;)); 开启服务器C:\\Users\\username\\Desktop\\reactApp&gt;npm start","tags":[{"name":"React","slug":"React","permalink":"http://hunghoo.github.io/tags/React/"}]},{"title":"设计模式之开闭原则","date":"2016-03-02T06:22:11.000Z","path":"2016/03/02/设计模式之开闭原则/","text":"开闭原则就是对扩展开放，对修改关闭 代码实例 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;开闭原则&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;开闭原则就是对扩展开放，对修改关闭&lt;/p&gt; &lt;script&gt; //创建calculator函数，对外提供add和remain方法 //外面的无法修改内部的属性方法，但是可以给calculator添加属性方法。 (function(calculator) &#123; function convert(input) &#123; return parseInt(input); &#125; calculator.add = function(a, b) &#123; return convert(a) + convert(b); &#125; window.calculator = calculator; &#125;)(window.calculator || &#123;&#125;); (function(calculator) &#123; calculator.remain = function(a, b) &#123; return a % b; &#125;; window.calculator = calculator; &#125;)(window.calculator || &#123;&#125;); alert(calculator.remain(1, 2)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hunghoo.github.io/tags/设计模式/"}]},{"title":"百度搜索框案例","date":"2015-04-01T03:39:18.000Z","path":"2015/04/01/百度搜索框案例/","text":"百度搜索框的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; fieldset, img, input, button &#123; border: none; padding: 0; margin: 0; outline-style: none; &#125; ul, ol &#123; list-style: none; margin: 0px; padding: 0px; &#125; #box &#123; width: 405px; margin: 200px auto; position: relative; &#125; #txtSearch &#123; float: left; width: 300px; height: 32px; padding-left: 4px; border: 1px solid #b6b6b6; border-right: 0; &#125; #btnSearch &#123; float: left; width: 100px; height: 34px; font: 400 14px/34px &quot;microsoft yahei&quot;; color: white; background: #3385ff; cursor: pointer; &#125; #btnSearch:hover &#123; background: #317ef3; &#125; #pop &#123; width: 303px; border: 1px solid #ccc; padding: 0px; position: absolute; top: 34px; &#125; #pop ul li &#123; padding-left: 5px; &#125; #pop ul li:hover &#123; background-color: #CCC; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;txtSearch&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;百度一下&quot; id=&quot;btnSearch&quot;&gt;&lt;/div&gt;&lt;script&gt; //真正的业务逻辑是 根据我们的输入 向有台发送数据 在后台匹配 把匹配好的发给我们 var datas = [&quot;a&quot;, &quot;abc&quot;, &quot;abbbb&quot;, &quot;abxxxx&quot;, &quot;xyz&quot;, &quot;abcdef&quot;, &quot;abzzzz&quot;]; //我们这里为了效果好看就在前台匹配了 //匹配的逻辑就是 从集合中找 如果 集合中的字符串是以我输入的字符串开头的就算匹配 //在文本框中输入 按照输入的内容 到datas里面 找匹配的项目 将匹配的项目放到新数组中 //输入的时候 判断匹配 var box = document.getElementById(&quot;box&quot;); var text = document.getElementById(&quot;txtSearch&quot;); text.onkeyup = function () &#123; var filterArr = []; var val = this.value;//文本框中的内容 //遍历datas 判断每一项是否匹配 for (var i = 0; i &lt; datas.length; i++) &#123; var data = datas[i];//每一项数据 if (data.indexOf(val) === 0) &#123;//当前这个数据 是以val开头的 filterArr.push(data);//把匹配的项目 放到新数组中 &#125; &#125; //console.log(filterArr); //1.判断之前有没有popDiv 如果有就移除 var popDiv = document.getElementById(&quot;pop&quot;); if (popDiv) &#123; box.removeChild(popDiv);//如果有 就把之前的移除 &#125; //2.如果没有匹配项 就不需要产生 popDiv if (filterArr.length === 0) &#123; return; &#125; //3.如果 文本框中是空字符串 不应该产生 popDiv if (val === &quot;&quot;) &#123; return; &#125; //根据filterArr动态生成结构 popDiv = document.createElement(&quot;div&quot;); popDiv.id = &quot;pop&quot;; box.appendChild(popDiv); var ul = document.createElement(&quot;ul&quot;); popDiv.appendChild(ul); //根据匹配数组 动态产生li for (var i = 0; i &lt; filterArr.length; i++) &#123; var item = filterArr[i]; var li = document.createElement(&quot;li&quot;); li.innerText = item; ul.appendChild(li); &#125; &#125;; //todo:当前高亮 //todo:点击当前li当前li中的文字会到输入框中 //todo:按上下键 可以切换（涉及到事件对象了，可以先了解一下试一下） //todo:可以自己看看百度搜索框还有哪些功能&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"特效案例","slug":"特效案例","permalink":"http://hunghoo.github.io/tags/特效案例/"}]},{"title":"emmet语法简介","date":"2015-01-02T07:11:28.000Z","path":"2015/01/02/emmet语法简介/","text":"对于为一个前端程序员，emmet可以说是作为一个神器的存在，可以让我们的coding效率提高很多。所以我就整理了下常用的emmet使用方法。 一 html1.初始化 如何快速搭建一个h5的结构，只需要一个命令 12! + tab键 或者 html:5 + tab键 如果要构建xhtml或者严格类型文档12html:xt --&gt; 过度文档类型html:4s --&gt; 严格文档类型 2.添加类 id 文本和属性 输入 .类名 或者 #id 单击tab键，就可以生成 1&lt;div class = &quot;classname&quot;&gt;&lt;/div&gt;或者&lt;div di=&quot;idname&quot;&gt;&lt;/div&gt; 默认生成div标签 如果添加上标签名，就会生成标签名和相应的class和id123eg： p.classname + tab --&gt;&lt;p class=&quot;classname&quot;&gt;&lt;/p&gt; p#idname + tab --&gt; &lt;p id=&quot;idname&quot;&gt;&lt;/p&gt; 也可以连写1p#idname.classname + tab --&gt; &lt;p id=&quot;idname&quot; class=&quot;calssname&quot;&gt;&lt;/p&gt; 如何生成内容和属性12p&#123;cont&#125; + tab --&gt; &lt;p&gt;cont&lt;/p&gt;a[href=&quot;#&quot;] + tab --&gt; &lt;a href=&quot;#&quot;&gt;&lt;/a&gt; 嵌套方式 来看例子12p&gt;span + tab --&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;p+div + tab --&gt; &lt;p&gt;&lt;/p&gt; &lt;div&gt;&lt;/div&gt; 分组 我们也可以通过嵌套和括号来生成代码块123456(.classname&gt;h1)+(#idname+h2)--&gt; &lt;div class=&quot;classname&quot;&gt; &lt;h1&gt;&lt;/h1&gt; &lt;/div&gt; &lt;div id=&quot;idname&quot;&gt;&lt;/div&gt; &lt;h2&gt;&lt;/h2&gt; 定义多个元素 使用*生成多个元素1234567ul&gt;li*3 -- &gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; 定义多个带属性的元素 使用$来生成序号1234567ul&gt;li.classname$*3--&gt; &lt;ul&gt; &lt;li class=&quot;classname1&quot;&gt;&lt;/li&gt; &lt;li class=&quot;classname2&quot;&gt;&lt;/li&gt; &lt;li class=&quot;classname3&quot;&gt;&lt;/li&gt; &lt;/ul&gt; 二 css快速写法1.值 大多数的属性默认生成单位是px, 不写就默认px e –&gt; em p –&gt; %123456eg:w100 --&gt; width:100px;w2e--&gt;width: 3em; 2.附加属性1234567891011@f+ -- &gt; @font-face &#123; font-family: &apos;FontName&apos;; src: url(&apos;FileName.eot&apos;); src: url(&apos;FileName.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;), url(&apos;FileName.woff&apos;) format(&apos;woff&apos;), url(&apos;FileName.ttf&apos;) format(&apos;truetype&apos;), url(&apos;FileName.svg#FontName&apos;) format(&apos;svg&apos;); font-style: normal; font-weight: normal; &#125; 3.添加兼容 -属性名 1234567-display -- &gt; -webkit-display: ; -moz-display: ; -ms-display: ; -o-display: ; display: ; emmet还有许多隐藏的快捷方式，常用的就是这么多…..","tags":[{"name":"emmet","slug":"emmet","permalink":"http://hunghoo.github.io/tags/emmet/"}]}]